<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arcade Shooter</title>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3079065410615131" crossorigin="anonymous"></script>
  <style>
    :root { --bg:#040712; --fg:#e6f0ff; --acc:#57f2c2; --warn:#ffd166; }
    * { box-sizing:border-box; }
    body {
      margin:0; min-height:100vh; display:grid; place-items:center;
      font-family:Consolas,Monaco,"Courier New",monospace; color:var(--fg);
      background:radial-gradient(1000px 650px at 20% 20%,#14213a 0,transparent 45%), radial-gradient(800px 520px at 80% 75%,#13253f 0,transparent 50%), var(--bg);
      overflow:hidden;
    }
    .wrap { display:grid; gap:10px; justify-items:center; }
    canvas {
      border:2px solid #1d2b46; border-radius:10px; background:#02050f;
      box-shadow:0 20px 80px rgba(0,0,0,.55),0 0 0 1px rgba(87,242,194,.12) inset;
      image-rendering:pixelated;
    }
    .controls { display:flex; align-items:center; gap:10px; }
    button {
      border:1px solid rgba(87,242,194,.45); background:rgba(11,18,34,.9); color:#d9fff3;
      border-radius:8px; padding:8px 14px; cursor:pointer; font:600 13px Consolas,monospace;
    }
    .status { font-size:12px; opacity:.86; }
    .hint {
      padding:8px 12px; border-radius:8px; background:rgba(11,18,34,.8);
      border:1px solid rgba(87,242,194,.25); font-size:13px; text-align:center; line-height:1.35;
    }
    .key { color:var(--warn); }
    .partner-form {
      position:fixed; right:18px; top:18px; width:min(320px,calc(100vw - 36px));
      padding:14px; border-radius:12px;
      background:
        linear-gradient(180deg,rgba(16,30,56,.92),rgba(6,12,24,.92)),
        repeating-linear-gradient(90deg,rgba(87,242,194,.04) 0 1px,transparent 1px 12px);
      border:1px solid rgba(87,242,194,.35);
      box-shadow:0 14px 34px rgba(0,0,0,.35),0 0 0 1px rgba(87,242,194,.18) inset;
      backdrop-filter:blur(3px);
      overflow:hidden;
    }
    .partner-form::before {
      content:"PARTNERSHIP LINK";
      display:block; margin:-14px -14px 12px; padding:7px 10px;
      border-bottom:1px solid rgba(87,242,194,.35);
      background:linear-gradient(90deg,rgba(87,242,194,.18),rgba(87,242,194,.04));
      color:#a8ffe6; font-size:11px; letter-spacing:.08em; font-weight:700;
    }
    .partner-form h2 {
      margin:0 0 10px; font-size:14px; color:#f1fffa; text-shadow:0 0 8px rgba(87,242,194,.25);
    }
    .partner-form label {
      display:block; margin:8px 0 4px; font-size:12px; opacity:.9; color:#9cd7ff;
    }
    .partner-form input,
    .partner-form textarea {
      width:100%; border-radius:8px; padding:8px 10px;
      border:1px solid rgba(87,242,194,.3);
      background:linear-gradient(180deg,#101d39,#0a1429); color:var(--fg);
      font:13px Consolas,Monaco,"Courier New",monospace;
      outline:none; transition:border-color .15s ease, box-shadow .15s ease;
    }
    .partner-form input:focus,
    .partner-form textarea:focus {
      border-color:rgba(87,242,194,.85);
      box-shadow:0 0 0 2px rgba(87,242,194,.2), 0 0 14px rgba(87,242,194,.18);
    }
    .partner-form textarea { resize:vertical; min-height:88px; }
    .partner-form button {
      margin-top:10px; width:100%;
      border:1px solid rgba(87,242,194,.65);
      background:linear-gradient(180deg,#1f4f58,#15303b);
      color:#e8fff8; font-weight:700; letter-spacing:.02em;
      text-shadow:0 0 8px rgba(87,242,194,.25);
      box-shadow:0 8px 20px rgba(0,0,0,.3),0 0 14px rgba(87,242,194,.14) inset;
    }
    .partner-form button:hover {
      border-color:rgba(87,242,194,.95);
      filter:brightness(1.05);
    }
    .partner-form .note {
      margin:8px 0 0; font-size:11px; opacity:.78; color:#afc4e6;
    }
    .comments-panel {
      position:fixed; left:18px; top:18px; width:min(320px,calc(100vw - 36px));
      padding:14px; border-radius:12px;
      background:
        linear-gradient(180deg,rgba(13,24,49,.92),rgba(6,12,24,.92)),
        repeating-linear-gradient(90deg,rgba(156,230,255,.04) 0 1px,transparent 1px 12px);
      border:1px solid rgba(156,230,255,.35);
      box-shadow:0 14px 34px rgba(0,0,0,.35),0 0 0 1px rgba(156,230,255,.16) inset;
      backdrop-filter:blur(3px);
      overflow:hidden;
      max-height:min(560px,calc(100vh - 36px));
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .comments-panel::before {
      content:"PILOT CHAT";
      display:block; margin:-14px -14px 8px; padding:7px 10px;
      border-bottom:1px solid rgba(156,230,255,.35);
      background:linear-gradient(90deg,rgba(156,230,255,.18),rgba(156,230,255,.04));
      color:#d6f1ff; font-size:11px; letter-spacing:.08em; font-weight:700;
    }
    .comments-panel h2 {
      margin:0; font-size:14px; color:#f1f8ff;
    }
    #disqus_thread {
      flex:1;
      overflow:auto;
      background:rgba(6,12,24,.55);
      border:1px solid rgba(156,230,255,.22);
      border-radius:8px;
      padding:6px;
    }
    @media (max-width: 900px) {
      .comments-panel {
        top:12px; left:12px; right:12px; width:auto; max-height:42vh;
      }
      .partner-form {
        top:auto; bottom:12px; right:12px; left:12px; width:auto;
      }
    }
  </style>
</head>
<body>
  <section class="comments-panel">
    <h2>댓글</h2>
    <div id="disqus_thread"></div>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </section>

  <form class="partner-form" action="https://formspree.io/f/xykdprqy" method="POST">
    <h2>제휴 문의</h2>
    <input type="hidden" name="_subject" value="신규 제휴 문의" />
    <label for="company">회사/브랜드명</label>
    <input id="company" name="company" type="text" required />
    <label for="name">담당자명</label>
    <input id="name" name="name" type="text" required />
    <label for="email">이메일</label>
    <input id="email" name="email" type="email" required />
    <label for="message">문의 내용</label>
    <textarea id="message" name="message" required></textarea>
    <button type="submit">문의 보내기</button>
    <p class="note">제출 시 Formspree로 전송됩니다.</p>
  </form>

  <div class="wrap">
    <canvas id="game" width="480" height="720"></canvas>
    <div class="controls">
      <button id="pauseBtn">Pause</button>
      <span class="status" id="statusText">Running</span>
    </div>
    <div class="hint">
      Move <span class="key">Arrow / WASD</span> | Shoot <span class="key">Space / Z</span> | Focus <span class="key">Shift</span><br/>
      Charge <span class="key">Hold X</span> | Bomb <span class="key">C</span> | Pause <span class="key">P / Button</span> | Restart <span class="key">Enter</span>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const pauseBtn = document.getElementById("pauseBtn");
    const statusText = document.getElementById("statusText");
    const W = canvas.width;
    const H = canvas.height;
    const keys = {};

    const audio = { ctx:null, m:null, bg:null, sfx:null, noise:null, timer:null, step:0 };

    function initAudio() {
      if (audio.ctx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      audio.ctx = new AC();
      audio.m = audio.ctx.createGain();
      audio.m.gain.value = 0.6;
      audio.m.connect(audio.ctx.destination);
      audio.bg = audio.ctx.createGain();
      audio.bg.gain.value = 0.14;
      audio.bg.connect(audio.m);
      audio.sfx = audio.ctx.createGain();
      audio.sfx.gain.value = 0.22;
      audio.sfx.connect(audio.m);
      const len = audio.ctx.sampleRate;
      const buf = audio.ctx.createBuffer(1, len, audio.ctx.sampleRate);
      const d = buf.getChannelData(0);
      for (let i = 0; i < len; i++) d[i] = Math.random() * 2 - 1;
      audio.noise = buf;
      startBgm();
    }

    function resumeAudio() {
      if (audio.ctx && audio.ctx.state !== "running") audio.ctx.resume();
    }

    function tone(freq, dur, type, vol, glide = null) {
      if (!audio.ctx) return;
      const t = audio.ctx.currentTime;
      const o = audio.ctx.createOscillator();
      const g = audio.ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t);
      if (glide) o.frequency.exponentialRampToValueAtTime(Math.max(20, glide), t + dur);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(vol, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
      o.connect(g); g.connect(audio.sfx);
      o.start(t); o.stop(t + dur + 0.02);
    }

    function noise(dur, vol, f0 = 1600, f1 = 220) {
      if (!audio.ctx || !audio.noise) return;
      const t = audio.ctx.currentTime;
      const src = audio.ctx.createBufferSource(); src.buffer = audio.noise;
      const f = audio.ctx.createBiquadFilter(); f.type = "lowpass";
      f.frequency.setValueAtTime(f0, t);
      f.frequency.exponentialRampToValueAtTime(Math.max(30, f1), t + dur);
      const g = audio.ctx.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(vol, t + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
      src.connect(f); f.connect(g); g.connect(audio.sfx);
      src.start(t); src.stop(t + dur + 0.02);
    }

    function midi(n) { return 440 * Math.pow(2, (n - 69) / 12); }

    function startBgm() {
      if (!audio.ctx || audio.timer) return;
      const lead = [72, 76, 79, 81, 79, 76, 74, 76, 71, 74, 78, 79, 78, 74, 72, 74];
      const bass = [48, 48, 50, 50, 45, 45, 47, 47];
      audio.timer = setInterval(() => {
        if (!audio.ctx || state.paused || state.gameOver) return;
        const t = audio.ctx.currentTime;
        const l = lead[audio.step % lead.length];
        const b = bass[audio.step % bass.length];
        const o1 = audio.ctx.createOscillator();
        const g1 = audio.ctx.createGain();
        o1.type = "triangle"; o1.frequency.setValueAtTime(midi(l), t);
        g1.gain.setValueAtTime(0.0001, t);
        g1.gain.exponentialRampToValueAtTime(0.12, t + 0.01);
        g1.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);
        o1.connect(g1); g1.connect(audio.bg); o1.start(t); o1.stop(t + 0.2);
        if (audio.step % 2 === 0) {
          const o2 = audio.ctx.createOscillator();
          const g2 = audio.ctx.createGain();
          o2.type = "sawtooth"; o2.frequency.setValueAtTime(midi(b), t);
          g2.gain.setValueAtTime(0.0001, t);
          g2.gain.exponentialRampToValueAtTime(0.07, t + 0.01);
          g2.gain.exponentialRampToValueAtTime(0.0001, t + 0.22);
          o2.connect(g2); g2.connect(audio.bg); o2.start(t); o2.stop(t + 0.24);
        }
        audio.step++;
      }, 185);
    }

    function sfx(name) {
      if (!audio.ctx || state.paused) return;
      if (name === "shot") tone(900, 0.06, "square", 0.03, 700);
      else if (name === "enemy") { tone(180, 0.18, "sawtooth", 0.06, 90); noise(0.14, 0.04, 1200, 240); }
      else if (name === "pickup") tone(620, 0.08, "triangle", 0.04, 930);
      else if (name === "chargeReady") tone(420, 0.16, "sawtooth", 0.05, 980);
      else if (name === "charge") { tone(220, 0.2, "sawtooth", 0.07, 1200); noise(0.2, 0.05, 2800, 380); }
      else if (name === "bomb") { tone(80, 0.55, "sawtooth", 0.12, 32); noise(0.6, 0.1, 1800, 120); }
      else if (name === "boss") tone(330, 0.08, "square", 0.03, 250);
      else if (name === "hit") { tone(140, 0.26, "square", 0.08, 55); noise(0.22, 0.05, 1300, 120); }
    }

    const state = {
      t:0, score:0, level:1, gameOver:false, paused:false,
      spawn:0, levelT:0, stars:[], pBullets:[], eBullets:[], enemies:[], fx:[],
      pickups:[], shock:[], bombWaves:[], boss:null, bossLevel:0,
      bombFlash:0, shake:0, nextId:1, prevCharge:false, prevBomb:false, chargeReady:false
    };

    const player = {
      x:W/2, y:H-90, w:24, h:34, speed:300, focus:170, fireDelay:100, fireT:0,
      lives:3, power:1, inv:0, bombs:3, charge:0, charging:false, maxCharge:1.2
    };

    function initStars() {
      state.stars.length = 0;
      for (let i = 0; i < 110; i++) {
        state.stars.push({ x:Math.random()*W, y:Math.random()*H, r:Math.random()*1.8+.4, v:Math.random()*70+40 });
      }
    }

    function resetGame() {
      Object.assign(state, {
        t:0, score:0, level:1, gameOver:false, paused:false, spawn:0, levelT:0, boss:null,
        bossLevel:0, bombFlash:0, shake:0, nextId:1, prevCharge:false, prevBomb:false, chargeReady:false
      });
      state.pBullets.length = 0; state.eBullets.length = 0; state.enemies.length = 0;
      state.fx.length = 0; state.pickups.length = 0; state.shock.length = 0; state.bombWaves.length = 0;
      Object.assign(player, { x:W/2, y:H-90, lives:3, power:1, inv:0, fireT:0, bombs:3, charge:0, charging:false });
      pauseBtn.textContent = "Pause";
      statusText.textContent = "Running";
      initStars();
    }

    function togglePause(next = !state.paused) {
      if (state.gameOver) return;
      state.paused = next;
      pauseBtn.textContent = state.paused ? "Resume" : "Pause";
      statusText.textContent = state.paused ? "Paused" : "Running";
      if (audio.ctx) {
        if (state.paused) audio.ctx.suspend();
        else audio.ctx.resume();
      }
    }

    pauseBtn.addEventListener("click", () => { initAudio(); resumeAudio(); togglePause(); });

    addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      keys[k] = true;
      initAudio(); resumeAudio();
      if (["arrowup","arrowdown","arrowleft","arrowright"," "].includes(k)) e.preventDefault();
      if (k === "p" && !e.repeat) togglePause();
      if (state.gameOver && e.key === "Enter") resetGame();
    });
    addEventListener("keyup", (e) => { keys[e.key.toLowerCase()] = false; });
    addEventListener("pointerdown", () => { initAudio(); resumeAudio(); });

    function burst(x, y, color, n = 16, speed = 180) {
      for (let i = 0; i < n; i++) {
        const a = Math.random() * Math.PI * 2;
        const v = Math.random() * speed;
        state.fx.push({ x, y, vx:Math.cos(a)*v, vy:Math.sin(a)*v, life:.35+Math.random()*.35, max:.35+Math.random()*.35, color });
      }
    }

    function collide(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const rr = a.r + b.r;
      return dx*dx + dy*dy <= rr*rr;
    }

    function killEnemy(i) {
      const e = state.enemies[i];
      state.score += e.points;
      burst(e.x, e.y, "#ff9b73", e.type === "shooter" ? 24 : 14, 220);
      dropPickup(e.x, e.y);
      state.enemies.splice(i, 1);
      sfx("enemy");
    }
    function dropPickup(x, y) {
      const r = Math.random();
      if (r < 0.16) state.pickups.push({ x, y, r:9, vy:90, kind:"power" });
      else if (r < 0.2) state.pickups.push({ x, y, r:10, vy:90, kind:"bomb" });
    }

    function shootNormal() {
      const p = player.power;
      const s = 560;
      const base = { x:player.x, y:player.y-player.h*.45, vx:0, vy:-s, r:4, dmg:1, pierce:0, charge:false };
      state.pBullets.push({ ...base });
      if (p >= 2) {
        state.pBullets.push({ ...base, x:player.x-12, vx:-40 });
        state.pBullets.push({ ...base, x:player.x+12, vx:40 });
      }
      if (p >= 3) {
        state.pBullets.push({ ...base, x:player.x-20, vx:-90 });
        state.pBullets.push({ ...base, x:player.x+20, vx:90 });
      }
      if (p >= 4) state.pBullets.push({ ...base, vy:-650, dmg:2, r:5 });
      sfx("shot");
    }

    function wave(x, y, maxR, dmg, color, isBomb = false) {
      const o = { x, y, r:8, maxR, speed:isBomb?860:520, dmg, life:isBomb?1.3:.8, hit:new Set(), color };
      if (isBomb) state.bombWaves.push(o);
      else state.shock.push(o);
    }

    function releaseCharge() {
      const ratio = Math.min(1, player.charge / player.maxCharge);
      if (ratio < 0.18) { player.charge = 0; return; }
      const shots = 3 + Math.floor(ratio * 2);
      const spread = 0.5;
      for (let i = 0; i < shots; i++) {
        const t = shots === 1 ? 0 : i / (shots - 1);
        const a = -Math.PI/2 + (t - 0.5) * spread;
        const speed = 430 + ratio * 250;
        state.pBullets.push({
          x:player.x, y:player.y-player.h*.5,
          vx:Math.cos(a)*speed, vy:Math.sin(a)*speed,
          r:7+ratio*8, dmg:5+ratio*9, pierce:4+Math.floor(ratio*4),
          charge:true, aoeR:95+ratio*170, aoeD:4+ratio*7
        });
      }
      wave(player.x, player.y-24, 110+ratio*180, 4+ratio*6, "rgba(124,249,255,0.85)");
      burst(player.x, player.y-8, "#7cf9ff", 34, 250);
      state.shake = Math.max(state.shake, .22);
      sfx("charge");
      player.charge = 0;
      player.charging = false;
      state.chargeReady = false;
    }

    function detonateCharge(b) {
      wave(b.x, b.y, b.aoeR || 120, b.aoeD || 6, "rgba(114,214,255,0.9)");
      burst(b.x, b.y, "#9ce6ff", 20, 190);
    }

    function useBomb() {
      if (player.bombs <= 0 || state.gameOver) return;
      player.bombs -= 1;
      player.inv = Math.max(player.inv, 1.2);
      state.bombFlash = .75;
      state.shake = Math.max(state.shake, .55);
      wave(player.x, player.y, 980, 26 + state.level * 2, "rgba(255,224,138,.95)", true);
      burst(player.x, player.y, "#ffe08a", 110, 370);
      sfx("bomb");
    }

    function spawnEnemy() {
      const r = Math.random();
      const lv = state.level;
      let type = "basic";
      if (r > .72) type = "zigzag";
      if (r > .9 && lv >= 2) type = "shooter";
      state.enemies.push({
        id:state.nextId++, type,
        x:Math.random()*(W-60)+30, y:-40,
        r:type === "shooter" ? 20 : 16,
        hp:type === "shooter" ? 6+lv : (type === "zigzag" ? 3+lv*.5 : 2+lv*.4),
        speed:type === "basic" ? 85+lv*8 : (type === "zigzag" ? 110+lv*10 : 70+lv*6),
        phase:Math.random()*Math.PI*2,
        fire:600+Math.random()*700,
        points:type === "shooter" ? 280 : (type === "zigzag" ? 150 : 90)
      });
    }

    function spawnBoss() {
      const hp = 260 + state.level * 70;
      state.boss = {
        id:"boss", x:W/2, y:-90, targetY:108, r:44, hp, maxHp:hp,
        phase:0, fire:.7, modeT:0, mode:0, angle:0, points:4000+state.level*400
      };
      state.bossLevel = state.level;
      burst(W/2, 40, "#ff9b73", 30, 180);
    }

    function killBoss() {
      if (!state.boss) return;
      state.score += state.boss.points;
      burst(state.boss.x, state.boss.y, "#ff9b73", 130, 360);
      for (let i = 0; i < 3; i++) state.pickups.push({ x:state.boss.x+(i-1)*24, y:state.boss.y, r:9, vy:90, kind:"power" });
      state.pickups.push({ x:state.boss.x, y:state.boss.y-16, r:10, vy:100, kind:"bomb" });
      state.eBullets.length = 0;
      state.shake = Math.max(state.shake, .46);
      state.bombFlash = Math.max(state.bombFlash, .4);
      sfx("enemy");
      state.boss = null;
    }

    function updateBoss(dt) {
      const b = state.boss;
      if (!b) return;
      if (b.y < b.targetY) { b.y += 120 * dt; return; }
      b.phase += dt;
      b.modeT += dt;
      b.angle += dt * 1.6;
      b.x = W/2 + Math.sin(b.phase * 1.1) * 120;
      if (b.modeT >= 5.5) { b.modeT = 0; b.mode = (b.mode + 1) % 3; }
      b.fire -= dt;
      if (b.fire > 0) return;
      if (b.mode === 0) {
        const n = 14;
        const sp = 165 + state.level * 7;
        for (let i = 0; i < n; i++) {
          const a = b.angle + (Math.PI*2*i)/n;
          state.eBullets.push({ x:b.x, y:b.y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, r:5 });
        }
        b.fire = .6;
      } else if (b.mode === 1) {
        const dx = player.x - b.x;
        const dy = player.y - b.y;
        const base = Math.atan2(dy, dx);
        const spread = .58;
        for (let i = -3; i <= 3; i++) {
          const a = base + i*(spread/3);
          const sp = 230 + state.level * 8;
          state.eBullets.push({ x:b.x, y:b.y+6, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, r:5 });
        }
        b.fire = .45;
      } else {
        const leftX = b.x - 28;
        const rightX = b.x + 28;
        const w = Math.sin(b.phase * 5.5) * .85;
        const sp = 240 + state.level * 9;
        const a1 = Math.PI/2 + w;
        const a2 = Math.PI/2 - w;
        state.eBullets.push({ x:leftX, y:b.y+8, vx:Math.cos(a1)*sp, vy:Math.sin(a1)*sp, r:4.5 });
        state.eBullets.push({ x:rightX, y:b.y+8, vx:Math.cos(a2)*sp, vy:Math.sin(a2)*sp, r:4.5 });
        b.fire = .11;
      }
      sfx("boss");
    }

    function hitPlayer() {
      if (player.inv > 0 || state.gameOver) return;
      player.lives -= 1;
      player.inv = 2;
      player.charge = 0;
      player.charging = false;
      state.chargeReady = false;
      burst(player.x, player.y, "#7cc7ff", 24, 220);
      if (player.power > 1) player.power -= 1;
      sfx("hit");
      if (player.lives <= 0) { state.gameOver = true; statusText.textContent = "Game Over"; }
    }

    function applyWavesDamage() {
      for (const w of state.shock) {
        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const e = state.enemies[i];
          if (w.hit.has(e.id)) continue;
          if (Math.hypot(e.x - w.x, e.y - w.y) <= w.r + e.r) {
            w.hit.add(e.id);
            e.hp -= w.dmg;
            if (e.hp <= 0) killEnemy(i);
          }
        }
        if (state.boss && !w.hit.has("boss") && Math.hypot(state.boss.x - w.x, state.boss.y - w.y) <= w.r + state.boss.r) {
          w.hit.add("boss");
          state.boss.hp -= w.dmg * 1.05;
          if (state.boss.hp <= 0) killBoss();
        }
      }

      for (const b of state.bombWaves) {
        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const e = state.enemies[i];
          if (b.hit.has(e.id)) continue;
          if (Math.hypot(e.x - b.x, e.y - b.y) <= b.r + e.r) {
            b.hit.add(e.id);
            e.hp -= b.dmg;
            if (e.hp <= 0) killEnemy(i);
          }
        }
        if (state.boss && !b.hit.has("boss") && Math.hypot(state.boss.x - b.x, state.boss.y - b.y) <= b.r + state.boss.r) {
          b.hit.add("boss");
          state.boss.hp -= b.dmg * 1.25;
          if (state.boss.hp <= 0) killBoss();
        }
      }
    }

    function update(dt) {
      state.t += dt;
      if (state.gameOver || state.paused) {
        if (state.gameOver) updateFx(dt);
        return;
      }

      state.levelT += dt;
      if (state.levelT >= 20) { state.level += 1; state.levelT = 0; }

      for (const s of state.stars) {
        s.y += s.v * dt;
        if (s.y > H) { s.y = -3; s.x = Math.random() * W; }
      }

      const up = keys["arrowup"] || keys["w"];
      const down = keys["arrowdown"] || keys["s"];
      const left = keys["arrowleft"] || keys["a"];
      const right = keys["arrowright"] || keys["d"];
      const shoot = keys[" "] || keys["z"];
      const focus = keys["shift"];
      const chargeKey = keys["x"];
      const bombKey = keys["c"];

      const sp = focus ? player.focus : player.speed;
      let mx = 0, my = 0;
      if (up) my -= 1;
      if (down) my += 1;
      if (left) mx -= 1;
      if (right) mx += 1;
      const len = Math.hypot(mx, my) || 1;
      player.x += (mx/len) * sp * dt;
      player.y += (my/len) * sp * dt;
      player.x = Math.max(18, Math.min(W - 18, player.x));
      player.y = Math.max(24, Math.min(H - 24, player.y));

      if (chargeKey) {
        player.charging = true;
        player.charge = Math.min(player.maxCharge, player.charge + dt);
        if (player.charge >= player.maxCharge && !state.chargeReady) { sfx("chargeReady"); state.chargeReady = true; }
      }
      if (!chargeKey && state.prevCharge && player.charging) releaseCharge();
      if (!chargeKey && !player.charging) player.charge = Math.max(0, player.charge - dt * 2.4);
      state.prevCharge = chargeKey;

      player.fireT -= dt * 1000;
      if (shoot && !player.charging && player.fireT <= 0) { shootNormal(); player.fireT = player.fireDelay; }

      if (bombKey && !state.prevBomb) useBomb();
      state.prevBomb = bombKey;

      if (player.inv > 0) player.inv -= dt;
      if (state.bombFlash > 0) state.bombFlash -= dt;
      if (state.shake > 0) state.shake -= dt;

      const readyBoss = !state.boss && state.level >= 3 && state.level % 3 === 0 && state.bossLevel !== state.level && state.levelT >= 4;
      if (readyBoss) spawnBoss();

      if (!state.boss) {
        state.spawn += dt;
        const interval = Math.max(.26, .72 - state.level * .04);
        if (state.spawn >= interval) { spawnEnemy(); state.spawn = 0; }
      }
      for (const b of state.pBullets) { b.x += b.vx * dt; b.y += b.vy * dt; }
      for (let i = state.pBullets.length - 1; i >= 0; i--) {
        const b = state.pBullets[i];
        if (b.charge && (b.y < -16 || b.x < -30 || b.x > W + 30)) {
          detonateCharge(b);
          state.pBullets.splice(i, 1);
        }
      }

      for (const b of state.eBullets) { b.x += b.vx * dt; b.y += b.vy * dt; }
      if (state.bombWaves.length > 0) state.eBullets.length = 0;

      for (const e of state.enemies) {
        e.y += e.speed * dt;
        if (e.type === "zigzag") { e.phase += dt * 4; e.x += Math.sin(e.phase) * 120 * dt; }
        if (e.type === "shooter") {
          e.phase += dt * 1.7;
          e.x += Math.sin(e.phase) * 60 * dt;
          e.fire -= dt * 1000;
          if (e.fire <= 0) {
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const m = Math.hypot(dx, dy) || 1;
            const s = 220 + state.level * 10;
            state.eBullets.push({ x:e.x, y:e.y, vx:(dx/m)*s, vy:(dy/m)*s, r:5 });
            e.fire = Math.max(260, 850 - state.level * 35) + Math.random() * 250;
          }
        }
      }

      updateBoss(dt);
      for (const p of state.pickups) p.y += p.vy * dt;

      for (const w of state.shock) { w.r += w.speed * dt; w.life -= dt; }
      state.shock = state.shock.filter((w) => w.r < w.maxR && w.life > 0);
      for (const b of state.bombWaves) { b.r += b.speed * dt; b.life -= dt; }
      state.bombWaves = state.bombWaves.filter((b) => b.r < b.maxR && b.life > 0);

      applyWavesDamage();
      handleCollisions();
      cleanup();
      updateFx(dt);
    }

    function handleCollisions() {
      for (let i = state.pBullets.length - 1; i >= 0; i--) {
        const b = state.pBullets[i];
        if (state.boss && collide({ x:b.x, y:b.y, r:b.r }, state.boss)) {
          state.boss.hp -= b.dmg;
          if (!b.charge || b.pierce <= 0) {
            if (b.charge) detonateCharge(b);
            state.pBullets.splice(i, 1);
          } else {
            b.pierce -= 1;
            b.dmg *= 0.9;
          }
          burst(b.x, b.y, "#9ce6ff", b.charge ? 8 : 4, 100);
          if (state.boss && state.boss.hp <= 0) killBoss();
          continue;
        }

        for (let j = state.enemies.length - 1; j >= 0; j--) {
          const e = state.enemies[j];
          if (!collide({ x:b.x, y:b.y, r:b.r }, e)) continue;
          e.hp -= b.dmg;
          if (!b.charge || b.pierce <= 0) {
            if (b.charge) detonateCharge(b);
            state.pBullets.splice(i, 1);
          } else {
            b.pierce -= 1;
            b.dmg *= 0.86;
          }
          burst(b.x, b.y, "#9ce6ff", b.charge ? 8 : 4, 90);
          if (e.hp <= 0) killEnemy(j);
          break;
        }
      }

      for (let i = state.eBullets.length - 1; i >= 0; i--) {
        const b = state.eBullets[i];
        if (collide({ x:b.x, y:b.y, r:b.r }, { x:player.x, y:player.y, r:8 })) {
          state.eBullets.splice(i, 1);
          hitPlayer();
        }
      }

      for (let i = state.enemies.length - 1; i >= 0; i--) {
        const e = state.enemies[i];
        if (collide(e, { x:player.x, y:player.y, r:9 })) {
          state.enemies.splice(i, 1);
          burst(e.x, e.y, "#ff9b73", 16, 200);
          hitPlayer();
        }
      }

      if (state.boss && collide(state.boss, { x:player.x, y:player.y, r:9 })) hitPlayer();

      for (let i = state.pickups.length - 1; i >= 0; i--) {
        const p = state.pickups[i];
        if (!collide(p, { x:player.x, y:player.y, r:12 })) continue;
        state.pickups.splice(i, 1);
        if (p.kind === "bomb") {
          player.bombs = Math.min(5, player.bombs + 1);
          state.score += 200;
          burst(player.x, player.y, "#ffd782", 16, 140);
        } else {
          player.power = Math.min(4, player.power + 1);
          state.score += 120;
          burst(player.x, player.y, "#b8ffb7", 12, 140);
        }
        sfx("pickup");
      }
    }

    function cleanup() {
      state.pBullets = state.pBullets.filter((b) => b.y > -70 && b.y < H + 20 && b.x > -80 && b.x < W + 80);
      state.eBullets = state.eBullets.filter((b) => b.y > -40 && b.y < H + 40 && b.x > -40 && b.x < W + 40);
      state.enemies = state.enemies.filter((e) => e.y < H + 45 && e.x > -60 && e.x < W + 60);
      state.pickups = state.pickups.filter((p) => p.y < H + 20);
    }

    function updateFx(dt) {
      for (const p of state.fx) {
        p.life -= dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.985;
        p.vy *= 0.985;
      }
      state.fx = state.fx.filter((p) => p.life > 0);
    }

    function drawShip(x, y) {
      ctx.save();
      ctx.translate(x, y);
      ctx.fillStyle = "#dce8ff";
      ctx.beginPath();
      ctx.moveTo(0, -20); ctx.lineTo(-12, 16); ctx.lineTo(0, 10); ctx.lineTo(12, 16); ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "#57f2c2";
      ctx.beginPath();
      ctx.moveTo(0, -11); ctx.lineTo(-5, 8); ctx.lineTo(5, 8); ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "#7aa8ff";
      ctx.fillRect(-18, 2, 8, 4);
      ctx.fillRect(10, 2, 8, 4);
      if (player.charging) {
        const ratio = Math.min(1, player.charge / player.maxCharge);
        ctx.strokeStyle = `rgba(124,249,255,${0.45 + ratio * 0.55})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, 16 + ratio * 10, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawEnemy(e) {
      ctx.save();
      ctx.translate(e.x, e.y);
      if (e.type === "shooter") {
        ctx.fillStyle = "#ff6b6b";
        ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "#2a1022"; ctx.fillRect(-13, -3, 26, 6);
        ctx.fillStyle = "#ffd166"; ctx.fillRect(-4, -4, 8, 8);
      } else {
        ctx.fillStyle = e.type === "zigzag" ? "#ff9f4a" : "#8fd3ff";
        ctx.beginPath();
        ctx.moveTo(0, -15); ctx.lineTo(-14, 10); ctx.lineTo(0, 16); ctx.lineTo(14, 10); ctx.closePath();
        ctx.fill();
      }
      const maxHp = e.type === "shooter" ? 6 + state.level : (e.type === "zigzag" ? 3 + state.level * .5 : 2 + state.level * .4);
      const hp = Math.max(0, Math.min(1, e.hp / maxHp));
      ctx.fillStyle = "rgba(255,255,255,.18)"; ctx.fillRect(-16, -24, 32, 4);
      ctx.fillStyle = "#70ff9b"; ctx.fillRect(-16, -24, 32 * hp, 4);
      ctx.restore();
    }

    function drawBoss() {
      const b = state.boss;
      if (!b) return;
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.fillStyle = "#6b2a66";
      ctx.beginPath(); ctx.ellipse(0, 0, 52, 38, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = "#ff776f";
      ctx.beginPath(); ctx.arc(-20, 0, 13, 0, Math.PI * 2); ctx.arc(20, 0, 13, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = "#ffd166"; ctx.fillRect(-10, -8, 20, 16);
      ctx.strokeStyle = "rgba(255,210,120,.9)"; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(-38, 5); ctx.lineTo(-56, 15); ctx.moveTo(38, 5); ctx.lineTo(56, 15); ctx.stroke();
      ctx.restore();
    }

    function drawWaves() {
      for (const w of state.shock) {
        const a = Math.max(0, 1 - w.r / w.maxR);
        ctx.strokeStyle = `rgba(124,249,255,${a * .8})`;
        ctx.lineWidth = 4;
        ctx.beginPath(); ctx.arc(w.x, w.y, w.r, 0, Math.PI * 2); ctx.stroke();
      }
      for (const b of state.bombWaves) {
        const a = Math.max(0, 1 - b.r / b.maxR);
        const g = ctx.createRadialGradient(b.x, b.y, Math.max(8, b.r - 40), b.x, b.y, b.r + 16);
        g.addColorStop(0, `rgba(255,235,150,${a * .06})`);
        g.addColorStop(.7, `rgba(255,168,87,${a * .22})`);
        g.addColorStop(1, `rgba(255,95,109,${a * .06})`);
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r + 20, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = `rgba(255,224,138,${a * .95})`;
        ctx.lineWidth = 6;
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.stroke();
      }
    }

    function drawHUD() {
      ctx.fillStyle = "rgba(7,14,28,.76)";
      ctx.fillRect(10, 10, W - 20, 64);
      ctx.strokeStyle = "rgba(87,242,194,.35)";
      ctx.strokeRect(10, 10, W - 20, 64);

      ctx.fillStyle = "#e6f0ff";
      ctx.font = "bold 16px Consolas";
      ctx.textAlign = "left";
      ctx.fillText(`SCORE ${state.score}`, 20, 34);
      ctx.textAlign = "center";
      ctx.fillStyle = "#ffd166";
      ctx.fillText(`LEVEL ${state.level}`, W / 2, 34);
      ctx.textAlign = "right";
      ctx.fillStyle = "#ffb3bd";
      ctx.fillText(`LIFE ${player.lives}  PWR ${player.power}  BOMB ${player.bombs}`, W - 20, 34);

      const c = Math.min(1, player.charge / player.maxCharge);
      ctx.textAlign = "left";
      ctx.fillStyle = "#9ccfff";
      ctx.font = "12px Consolas";
      ctx.fillText("CHARGE", 20, 56);
      ctx.fillStyle = "rgba(255,255,255,.2)";
      ctx.fillRect(84, 47, 120, 12);
      ctx.fillStyle = c >= 1 ? "#ffd166" : "#57f2c2";
      ctx.fillRect(84, 47, 120 * c, 12);

      if (state.boss) {
        const r = Math.max(0, state.boss.hp / state.boss.maxHp);
        ctx.fillStyle = "rgba(255,255,255,.2)";
        ctx.fillRect(220, 47, W - 240, 12);
        ctx.fillStyle = "#ff6b6b";
        ctx.fillRect(220, 47, (W - 240) * r, 12);
        ctx.fillStyle = "#ffc0c6";
        ctx.fillText("BOSS", 220, 56);
      }
    }

    function render() {
      ctx.save();
      if (state.shake > 0 && !state.paused) {
        const s = state.shake * 8;
        ctx.translate((Math.random() - .5) * s, (Math.random() - .5) * s);
      }

      ctx.clearRect(0, 0, W, H);
      for (const s of state.stars) {
        ctx.fillStyle = `rgba(180,210,255,${0.35 + s.r * 0.28})`;
        ctx.fillRect(s.x, s.y, s.r, s.r * 1.8);
      }

      for (const p of state.pickups) {
        if (p.kind === "bomb") {
          ctx.fillStyle = "#ffd782";
          ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = "#5b3f09"; ctx.fillRect(p.x-4, p.y-4, 8, 8);
        } else {
          ctx.fillStyle = "#9cff99";
          ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = "#0f4620";
          ctx.fillRect(p.x-1.5, p.y-5, 3, 10);
          ctx.fillRect(p.x-5, p.y-1.5, 10, 3);
        }
      }

      for (const b of state.pBullets) {
        if (b.charge) {
          const g = ctx.createRadialGradient(b.x, b.y, 2, b.x, b.y, b.r + 8);
          g.addColorStop(0, "rgba(156,230,255,.98)");
          g.addColorStop(1, "rgba(87,242,194,.1)");
          ctx.fillStyle = g;
          ctx.beginPath(); ctx.arc(b.x, b.y, b.r + 8, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = "#9ce6ff";
          ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill();
        } else {
          ctx.fillStyle = "#9ce6ff";
          ctx.fillRect(b.x - 2, b.y - 8, 4, 12);
        }
      }

      for (const b of state.eBullets) {
        ctx.fillStyle = "#ff5f6d";
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill();
      }

      drawWaves();
      for (const e of state.enemies) drawEnemy(e);
      drawBoss();

      if (!(player.inv > 0 && Math.floor(state.t * 20) % 2 === 0) && !state.gameOver) drawShip(player.x, player.y);

      for (const p of state.fx) {
        const a = p.life / p.max;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = a;
        ctx.fillRect(p.x, p.y, 2.6, 2.6);
        ctx.globalAlpha = 1;
      }

      drawHUD();

      if (state.bombFlash > 0) {
        ctx.fillStyle = `rgba(255,224,138,${state.bombFlash * .42})`;
        ctx.fillRect(0, 0, W, H);
      }

      if (state.paused && !state.gameOver) {
        ctx.fillStyle = "rgba(2,5,15,.64)";
        ctx.fillRect(0, 0, W, H);
        ctx.textAlign = "center";
        ctx.fillStyle = "#8befff";
        ctx.font = "bold 38px Consolas";
        ctx.fillText("PAUSED", W/2, H/2);
      }

      if (state.gameOver) {
        ctx.fillStyle = "rgba(2,5,15,.72)";
        ctx.fillRect(0, 0, W, H);
        ctx.textAlign = "center";
        ctx.fillStyle = "#ff8894";
        ctx.font = "bold 42px Consolas";
        ctx.fillText("GAME OVER", W/2, H/2-30);
        ctx.fillStyle = "#e6f0ff";
        ctx.font = "20px Consolas";
        ctx.fillText(`Score: ${state.score}`, W/2, H/2+12);
        ctx.font = "16px Consolas";
        ctx.fillStyle = "#ffd166";
        ctx.fillText("Press Enter to Restart", W/2, H/2+52);
      }

      ctx.restore();
    }


    state.bgMountains = [];
    state.bgClouds = [];
    state.bgRuins = [];

    function initBackground() {
      state.bgMountains.length = 0;
      state.bgClouds.length = 0;
      state.bgRuins.length = 0;

      for (let i = 0; i < 16; i++) {
        state.bgMountains.push({
          x: Math.random() * W,
          y: Math.random() * H,
          w: 120 + Math.random() * 170,
          h: 60 + Math.random() * 90,
          speed: 18 + Math.random() * 12,
          c: `rgba(30,${45 + Math.floor(Math.random() * 18)},${55 + Math.floor(Math.random() * 25)},0.55)`
        });
      }

      for (let i = 0; i < 22; i++) {
        state.bgClouds.push({
          x: Math.random() * W,
          y: Math.random() * H,
          w: 46 + Math.random() * 90,
          h: 16 + Math.random() * 34,
          speed: 22 + Math.random() * 30,
          a: 0.07 + Math.random() * 0.18
        });
      }

      for (let i = 0; i < 24; i++) {
        state.bgRuins.push({
          x: Math.random() * W,
          y: Math.random() * H,
          w: 16 + Math.random() * 24,
          h: 40 + Math.random() * 90,
          speed: 70 + Math.random() * 40
        });
      }
    }

    function updateBackground(dt) {
      for (const m of state.bgMountains) {
        m.y += m.speed * dt;
        if (m.y - m.h > H + 10) {
          m.y = -m.h - Math.random() * 60;
          m.x = Math.random() * W;
        }
      }

      for (const c of state.bgClouds) {
        c.y += c.speed * dt;
        if (c.y - c.h > H + 20) {
          c.y = -c.h - Math.random() * 40;
          c.x = Math.random() * W;
        }
      }

      for (const r of state.bgRuins) {
        r.y += r.speed * dt;
        if (r.y - r.h > H + 12) {
          r.y = -r.h - Math.random() * 80;
          r.x = Math.random() * W;
        }
      }
    }

    function drawBackground() {
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, "#07122a");
      g.addColorStop(0.45, "#102742");
      g.addColorStop(1, "#254b3a");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);

      for (const m of state.bgMountains) {
        ctx.fillStyle = m.c;
        ctx.beginPath();
        ctx.moveTo(m.x - m.w * 0.5, m.y + m.h);
        ctx.lineTo(m.x, m.y);
        ctx.lineTo(m.x + m.w * 0.5, m.y + m.h);
        ctx.closePath();
        ctx.fill();
      }

      for (const c of state.bgClouds) {
        ctx.fillStyle = `rgba(216,241,255,${c.a})`;
        ctx.beginPath();
        ctx.ellipse(c.x, c.y, c.w * 0.45, c.h * 0.5, 0, 0, Math.PI * 2);
        ctx.ellipse(c.x - c.w * 0.2, c.y + 2, c.w * 0.32, c.h * 0.42, 0, 0, Math.PI * 2);
        ctx.ellipse(c.x + c.w * 0.22, c.y + 1, c.w * 0.3, c.h * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      for (const s of state.stars) {
        ctx.fillStyle = `rgba(180,210,255,${0.3 + s.r * 0.22})`;
        ctx.fillRect(s.x, s.y, s.r, s.r * 1.7);
      }

      for (const r of state.bgRuins) {
        ctx.fillStyle = "rgba(20,38,48,.78)";
        ctx.fillRect(r.x - r.w * 0.5, r.y - r.h, r.w, r.h);
        ctx.fillStyle = "rgba(111,215,179,.2)";
        for (let i = 0; i < 4; i++) {
          ctx.fillRect(r.x - r.w * 0.35, r.y - r.h + 8 + i * 12, r.w * 0.18, 4);
          ctx.fillRect(r.x + r.w * 0.17, r.y - r.h + 8 + i * 12, r.w * 0.18, 4);
        }
      }
    }

    drawShip = function(x, y) {
      ctx.save();
      ctx.translate(x, y);

      ctx.fillStyle = "#2a4f9a";
      ctx.fillRect(-7, -10, 14, 22);
      ctx.fillStyle = "#18315f";
      ctx.fillRect(-7, 3, 14, 9);

      ctx.fillStyle = "#f6c08f";
      ctx.beginPath();
      ctx.arc(0, -17, 7, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#2a1a12";
      ctx.beginPath();
      ctx.arc(0, -20, 8, Math.PI, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "#f6c08f";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-7, -5);
      ctx.lineTo(-16, 4);
      ctx.moveTo(7, -5);
      ctx.lineTo(16, 4);
      ctx.stroke();

      ctx.fillStyle = "#5f3c26";
      ctx.fillRect(-6, 12, 4, 9);
      ctx.fillRect(2, 12, 4, 9);

      ctx.fillStyle = "#6fd0ff";
      ctx.fillRect(-11, -2, 3, 8);
      ctx.fillRect(8, -2, 3, 8);

      if (player.charging) {
        const ratio = Math.min(1, player.charge / player.maxCharge);
        ctx.strokeStyle = `rgba(124,249,255,${0.45 + ratio * 0.55})`;
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.arc(0, 0, 16 + ratio * 12, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    };

    drawEnemy = function(e) {
      ctx.save();
      ctx.translate(e.x, e.y);
      if (e.type === "shooter") {
        ctx.fillStyle = "#6a2a2a";
        ctx.beginPath();
        ctx.ellipse(0, 0, 22, 18, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#bf4f4f";
        ctx.beginPath();
        ctx.arc(0, -1, 11, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#ffe8a8";
        ctx.beginPath();
        ctx.arc(-6, -3, 3.2, 0, Math.PI * 2);
        ctx.arc(6, -3, 3.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#2b0d0d";
        ctx.fillRect(-3, 2, 6, 5);
        ctx.strokeStyle = "#5f1f1f";
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(-16, 8); ctx.lineTo(-24, 16);
        ctx.moveTo(16, 8); ctx.lineTo(24, 16);
        ctx.stroke();
      } else if (e.type === "zigzag") {
        ctx.fillStyle = "#3d2a78";
        ctx.beginPath();
        ctx.ellipse(0, 1, 18, 15, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#9b77ff";
        ctx.beginPath();
        ctx.arc(0, -1, 9, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#d7c6ff";
        ctx.beginPath();
        ctx.arc(-5, -3, 2.6, 0, Math.PI * 2);
        ctx.arc(5, -3, 2.6, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#6a50ca";
        ctx.lineWidth = 2.2;
        ctx.beginPath();
        ctx.moveTo(-14, 9); ctx.lineTo(-20, 15);
        ctx.moveTo(14, 9); ctx.lineTo(20, 15);
        ctx.stroke();
      } else {
        ctx.fillStyle = "#2f6740";
        ctx.beginPath();
        ctx.ellipse(0, 2, 16, 13, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#67bd70";
        ctx.beginPath();
        ctx.arc(0, -1, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#f3ffe0";
        ctx.beginPath();
        ctx.arc(-4, -3, 2.2, 0, Math.PI * 2);
        ctx.arc(4, -3, 2.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#1e3f27";
        ctx.fillRect(-3, 1, 6, 4);
      }

      ctx.fillStyle = "#4b2f20";
      if (e.type === "basic") {
        ctx.fillRect(-5, 12, 4, 6);
        ctx.fillRect(1, 12, 4, 6);
      } else {
        ctx.fillRect(-7, 13, 5, 5);
        ctx.fillRect(2, 13, 5, 5);
      }

      const maxHp = e.type === "shooter" ? 6 + state.level : (e.type === "zigzag" ? 3 + state.level * .5 : 2 + state.level * .4);
      const hp = Math.max(0, Math.min(1, e.hp / maxHp));
      ctx.fillStyle = "rgba(255,255,255,.18)";
      ctx.fillRect(-18, -28, 36, 4);
      ctx.fillStyle = e.type === "shooter" ? "#ff9aa5" : "#70ff9b";
      ctx.fillRect(-18, -28, 36 * hp, 4);
      ctx.restore();
    };

    drawBoss = function() {
      const b = state.boss;
      if (!b) return;
      ctx.save();
      ctx.translate(b.x, b.y);

      ctx.fillStyle = "#3b1324";
      ctx.beginPath();
      ctx.ellipse(0, 4, 58, 46, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#7a2d4b";
      ctx.beginPath();
      ctx.ellipse(0, -4, 40, 33, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#ffceb0";
      ctx.beginPath();
      ctx.arc(-17, -8, 9, 0, Math.PI * 2);
      ctx.arc(17, -8, 9, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#1d0b11";
      ctx.beginPath();
      ctx.arc(-17, -8, 4, 0, Math.PI * 2);
      ctx.arc(17, -8, 4, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#d94f6e";
      ctx.beginPath();
      ctx.moveTo(-14, 8);
      ctx.lineTo(0, 18);
      ctx.lineTo(14, 8);
      ctx.lineTo(8, 24);
      ctx.lineTo(-8, 24);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "#521a30";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(-45, 12); ctx.lineTo(-64, 30);
      ctx.moveTo(45, 12); ctx.lineTo(64, 30);
      ctx.moveTo(-34, 34); ctx.lineTo(-46, 52);
      ctx.moveTo(34, 34); ctx.lineTo(46, 52);
      ctx.stroke();
      ctx.restore();
    };

    const __resetGame = resetGame;
    resetGame = function() {
      __resetGame();
      initBackground();
    };

    const __update = update;
    update = function(dt) {
      if (!state.paused && !state.gameOver) updateBackground(dt);
      __update(dt);
    };

    render = function() {
      ctx.save();
      if (state.shake > 0 && !state.paused) {
        const s = state.shake * 8;
        ctx.translate((Math.random() - .5) * s, (Math.random() - .5) * s);
      }

      ctx.clearRect(0, 0, W, H);
      drawBackground();

      for (const p of state.pickups) {
        if (p.kind === "bomb") {
          ctx.fillStyle = "#ffd782";
          ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = "#5b3f09"; ctx.fillRect(p.x-4, p.y-4, 8, 8);
        } else {
          ctx.fillStyle = "#9cff99";
          ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = "#0f4620";
          ctx.fillRect(p.x-1.5, p.y-5, 3, 10);
          ctx.fillRect(p.x-5, p.y-1.5, 10, 3);
        }
      }

      for (const b of state.pBullets) {
        if (b.charge) {
          const gr = ctx.createRadialGradient(b.x, b.y, 2, b.x, b.y, b.r + 8);
          gr.addColorStop(0, "rgba(156,230,255,.98)");
          gr.addColorStop(1, "rgba(87,242,194,.1)");
          ctx.fillStyle = gr;
          ctx.beginPath(); ctx.arc(b.x, b.y, b.r + 8, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = "#9ce6ff";
          ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill();
        } else {
          ctx.fillStyle = "#9ce6ff";
          ctx.fillRect(b.x - 2, b.y - 8, 4, 12);
        }
      }

      for (const b of state.eBullets) {
        ctx.fillStyle = "#ff5f6d";
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill();
      }

      drawWaves();
      for (const e of state.enemies) drawEnemy(e);
      drawBoss();

      if (!(player.inv > 0 && Math.floor(state.t * 20) % 2 === 0) && !state.gameOver) drawShip(player.x, player.y);

      for (const p of state.fx) {
        const a = p.life / p.max;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = a;
        ctx.fillRect(p.x, p.y, 2.6, 2.6);
        ctx.globalAlpha = 1;
      }

      drawHUD();

      if (state.bombFlash > 0) {
        ctx.fillStyle = `rgba(255,224,138,${state.bombFlash * .42})`;
        ctx.fillRect(0, 0, W, H);
      }

      if (state.paused && !state.gameOver) {
        ctx.fillStyle = "rgba(2,5,15,.64)";
        ctx.fillRect(0, 0, W, H);
        ctx.textAlign = "center";
        ctx.fillStyle = "#8befff";
        ctx.font = "bold 38px Consolas";
        ctx.fillText("PAUSED", W/2, H/2);
      }

      if (state.gameOver) {
        ctx.fillStyle = "rgba(2,5,15,.72)";
        ctx.fillRect(0, 0, W, H);
        ctx.textAlign = "center";
        ctx.fillStyle = "#ff8894";
        ctx.font = "bold 42px Consolas";
        ctx.fillText("GAME OVER", W/2, H/2-30);
        ctx.fillStyle = "#e6f0ff";
        ctx.font = "20px Consolas";
        ctx.fillText(`Score: ${state.score}`, W/2, H/2+12);
        ctx.font = "16px Consolas";
        ctx.fillStyle = "#ffd166";
        ctx.fillText("Press Enter to Restart", W/2, H/2+52);
      }

      ctx.restore();
    };

    let last = performance.now();
    function loop(now) {
      const dt = Math.min(.033, (now - last) / 1000);
      last = now;
      update(dt);
      render();
      requestAnimationFrame(loop);
    }

    resetGame();
    requestAnimationFrame(loop);
  </script>
  <script>
    var disqus_config = function () {
      this.page.url = window.location.href;
      this.page.identifier = window.location.pathname || "shooting-home";
    };
    (function() {
      var d = document, s = d.createElement("script");
      s.src = "https://shooting-1.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
</body>
</html>
